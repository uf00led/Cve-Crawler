import logging

from typing import Optional, Any
from copy import deepcopy

log = logging.getLogger(__name__)

def search(
    data: dict,
    path: str,
    sep: str = "."
) -> Any:
    """Function that returns an item from the dictionary along 
    the given path 
        
    :param data: search dictionary
    :type data: dict

    :param path: search path
    :type path: dict

    :return: element located in the given dictionary along 
        the given path
    :rtype: dict if success, else NoneType
    """
        
    path_trail = [node.strip() for node in path.split(sep)]
    search_data = data
        
    try:
        for node in path_trail:
            search_data = search_data[node]
        return search_data
        
    except KeyError as KE:
        log.info(f"KeyError: Dictionary hasn\'t element by path {path}.")
        return

def extract(
    data: list,
    fields: dict,
    sep: str = "."
) -> Optional[list]:
    """Function that retrieves fields from the data list of 
        dictionary
    
    :param data: dictionary with the data to be searched for
    :type data: dict
    
    :param fields: dictionary of correspondence between names 
        of extracted parameters and paths to these parameters
        usually given from a Parser.
    :type fields: dict
    
    :return: data dictionary from the given paths
    :rtype: dict if success, else NoneType i will change it 
        to Optional[dict] later. 

    data = '''{
        "Nested": {
            "One": {
                ...
            }
            "Another": [
                    Item_1,
                    Item_2,
                    ...
                    Item_n,
                ]
            }
        }
    }'''

    fields = {
        "name_1": "Nested.One",
        "name_2": "Nested.Another"
        ...
        "name_n": "Nested"
    }
    """
    
    extracted = {}
    parsed_data = []
        
    for entry in data:
        for field, path in fields.items():
            extracted[field] = search(
                data=entry,
                path=path,
                sep=sep
            )

            log.debug(
                f"Extracted data to '{field}' is {extracted[field]} by {path}."
            )
            
        parsed_data.append(deepcopy(extracted))
        extracted.clear()

    return parsed_data