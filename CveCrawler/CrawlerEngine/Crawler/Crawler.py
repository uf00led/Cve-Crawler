import logging

from typing import Optional
from concurrent.futures import ThreadPoolExecutor
from queue import Queue, Empty

from .Source import Source

log = logging.getLogger(__name__)

class Crawler():
    def __init__(
        self,
        source_queue: Queue,
        num_workers: int = 4
    ) -> None:
        log.debug(
            f"Crawler was successfully created with {num_workers}"
        )
        self._queue = source_queue # Should be got from RequestManager with sources
        self._pool = ThreadPoolExecutor(
            max_workers=num_workers
        )
        self._crawl_contents = list()
        self._crawled_sources = set()

    @property
    def result(
        self
    ) -> list:
        return self._crawl_contents

    @property
    def is_crawled(
        self
    ) -> bool:
        if len(self._crawl_contents):
            return True
        else:
            return False

    def _worker_crawl(
        self,
        source: Source
    ) -> Optional[dict]:
        content = source.download()
        if content is None:
            log.info(
                f"Content was not downloaded for {source.title}"
            )
            return
        
        parsed = source.parse(
            data=content,
        )
        if parsed is None:
            log.info(
                f"Content was not parsed for {source.title}"
            )
            return
        
        return parsed

    def _aggregate_content(
        self,
        parsed: Optional[dict]
    ) -> None:
        if parsed is not None:
            self._crawl_content.append(
                parsed
            )
        
    def crawl(
        self,
    ) -> None:
        while True:
            try:
                source = self._queue.get(timeout=30)
                self._crawled_sources.add(source.title)
                job = self._pool.submit(
                    self._worker_crawl, 
                    source=source,
                )
                job.add_done_callback(self._aggregate_content)
            except Empty:
                return
            except Exception as e:
                log.error(e)
                continue