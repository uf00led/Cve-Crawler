import logging

from typing import Optional, Any
from copy import deepcopy

log = logging.getLogger(__name__)

def search(
    data: dict,
    path: str,
    separator: str = "."
) -> Optional[Any]:
    """Function that returns an item from the dictionary along 
    the given path 
        
    :param data: search dictionary
    :type data: dict

    :param path: search path
    :type path: str

    :return: element located in the given dictionary along 
        the given path
    :rtype: Optional[Any]
    """
    
    if not data:
        log.info(
            "No data has been specified. The NoneType will be returned."
        )
        return

    if not path:
        log.info(
            "No path has been specified. The original data will be returned."
        )
        return data

    path_trail = [node.strip() for node in path.split(separator)]
    search_data = data
        
    try:
        for node in path_trail:
            search_data = search_data[node]
        return search_data
        
    except KeyError as kErr:
        log.info(f"KeyError: Dictionary hasn\'t element by path {path}.")
        return
    
    except Exception as exception:
        log.error(f"Exception: {exception}.")
        return

def extract(
    data: list,
    fields: dict,
    separator: str = "."
) -> list:
    """Function that retrieves fields from the data list of 
        dictionary
    
    :param data: dictionary with the data to be searched for
    :type data: dict
    
    :param fields: dictionary of correspondence between names 
        of extracted parameters and paths to these parameters
        usually given from a Parser.
    :type fields: dict
    
    :return: data dictionary from the given paths
    :rtype: list, if fields not found - empty list

    # Data Format
    {
        'Nested': {
            'One': {
                'Value': 10
            }, 
            'Another': [
                'Item_1', 'Item_2', 'Item_n'
            ]
        }
    }

    # Fields Format
    {
        "name_1": "Nested.One",
        "name_2": "Nested.Another"
        ...
        "name_n": "Nested"
    }
    
    # Output Format
    {
        "name_1": 10,
        "name_2": ['Item_1', 'Item_2', ... ,'Item_n']
        ...
        "name_n": {
            'One': {"Value": 10, ...}, 
            'Another': ['Item_1', 'Item_2', ..., 'Item_n']
        }
    }    
    """
    
    extracted_dict = {}
    parsed_data = []
        
    for entry in data:
        for field, path in fields.items():
            extracted = search(
                data=entry,
                path=path,
                separator=separator
            )

            if extracted is not None:
                extracted_dict[field] = extracted

            log.debug(
                f"Extracted data to '{field}' is {extracted} by {path}."
            )
        
        if extracted_dict:
            parsed_data.append(deepcopy(extracted_dict))
            extracted_dict.clear()

    return parsed_data