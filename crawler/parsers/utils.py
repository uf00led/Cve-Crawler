import logging

from re import compile
from typing import Optional, Any
from copy import deepcopy

log = logging.getLogger(__name__)

# Improve and make lexer. But it's not for now...
def condition(
    data: list,
    conditions: str,
    separator: str = "|"
) -> Any:
    conditions_dict = dict()
    if not conditions:
        print(data)

    try:
        for expression in conditions.split(sep=separator):
            keyword, value = expression.split('=')
            conditions_dict[keyword] = value
    
    except Exception as exception:
        log.error(
            f"Exception was acquired, while using conditions: {exception}"
        )
        return data[0]

    for entry in data:
        conditions = [
            value in str(entry[keyword])
            for keyword, value in conditions_dict.items()
        ]
        if all(conditions): return entry
    return data[0]

def search(
    data: dict,
    path: str,
    separator: str = ".",
) -> Optional[Any]:
    """Function that returns an item from the dictionary along 
    the given path 
        
    :param data: search dictionary
    :type data: dict

    :param path: search path
    :type path: str

    :return: element located in the given dictionary along 
        the given path
    :rtype: Optional[Any]
    """
    
    if not data:
        log.info(
            "No data has been specified. The NoneType will be returned."
        )
        return

    if not path:
        log.info(
            "No path has been specified. The original data will be returned."
        )
        return data

    path_trail = [node.strip() for node in path.split(separator)]
    search_data = data
    condition_regex = compile(r"\[(.+)\]")

    try:
        for node in path_trail:
            condition_check = condition_regex.search(node)
            
            if condition_check:
                cutted_node = condition_regex.sub(
                    string=node, 
                    repl=''
                )

                search_data = search_data[cutted_node]
                search_data = condition(
                    data=search_data,
                    conditions=condition_check.group(1)
                )
            else:
                search_data = search_data[node]
        return search_data
        
    except KeyError as kErr:
        log.debug(
            f"KeyError: Dictionary hasn\'t element by path {path}"
        )
        return
    
    except Exception as exception:
        log.error(
            f"Exception was acquired, while searching: {exception}"
        )
        return

def extract(
    data: list,
    fields: dict,
    separator: str = "."
) -> list:
    """Function that retrieves fields from the data list of 
        dictionary
    
    :param data: dictionary with the data to be searched for
    :type data: dict
    
    :param fields: dictionary of correspondence between names 
        of extracted parameters and paths to these parameters
        usually given from a Parser.
    :type fields: dict
    
    :return: data dictionary from the given paths
    :rtype: list, if fields not found - empty list

    # Data Format
    {
        'Nested': {
            'One': {
                'Value': 10
            }, 
            'Another': [
                'A1', 'A2', 'An'
            ],
            'Other': [
                {
                    'B': B1,
                    'C': C1,
                },
                {
                    'B': B2,
                    'C': C2,
                },
            ]
        }
    }

    # Fields Format
    {
        "name_1": "Nested.One",
        "name_2": "Nested.Another"
        "name_3": "Nested.Other[B=B1|C=C1]"
        ...
        "name_n": "Nested"
    }
    
    # Output Format
    {
        "name_1": 10,
        "name_2": ['A1', 'A2', ... ,'An']
        ...
        "name_n": {
            'One': {"Value": 10, ...}, 
            'Another': ['A1', 'A2', ..., 'An']
        }
    }    
    """
    
    extracted_dict = {}
    parsed_data = []
        
    for entry in data:
        for field, path in fields.items():
            extracted = search(
                data=entry,
                path=path,
                separator=separator
            )

            if extracted is not None: # Can be empty list or dict
                extracted_dict[field] = extracted

            log.debug(
                f"Extracted data to '{field}' is {extracted} by {path}"
            )
        
        if extracted_dict:
            parsed_data.append(deepcopy(extracted_dict))
            extracted_dict.clear()

    return parsed_data