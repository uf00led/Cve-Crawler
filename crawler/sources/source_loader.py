import logging

from typing import Optional
from pathlib import Path

from yaml import (
    safe_load, 
    YAMLError
)

from pydantic import (
    ValidationError
)

from .source import (
    Source
)

from .rules_models import (
    ParserModel,
    DownloaderModel,
    SourceModel
)

from ..downloaders import (
    IDownloader,
    DownloaderRequests,
    DownloaderSelenium
)

from ..parsers import (
    IParser,
    ParserJson,
    ParserXml,
)

log = logging.getLogger(__name__)

class SourceLoader():
    def __init__(
        self,
        rules_path: str = "./sources_rules"
    ) -> None:
        file_dir = f"{Path(__file__).parent}/"
        
        self._rules_pattern = "*.yaml"
        self._rules_dir = Path(file_dir + rules_path)
        self._sources = list()

        self._downloaders = {
            'Requests': DownloaderRequests,
            'Selenium': DownloaderSelenium
        }

        self._parsers = {
            'Json': ParserJson,
            'Xml' : ParserXml
        }

        self._model_items = lambda model: model.model_dump().items()

    @property
    def sources(
        self
    ) -> list:
        return self._sources
    
    @property
    def is_loaded(
        self
    ) -> bool:
        return True if len(self._sources) else False
    
    def _yaml_load(
        self,
        data: Optional[str]
    ):
        try:
            yaml_dict = safe_load(data)
        except YAMLError as decodeError:
            log.error(
                f"YAMLError: Failed to decode the data into YAML. {decodeError}"
            )
            return
        return yaml_dict

    def _create_downloader(
        self,
        downloader_model: DownloaderModel,
    ) -> IDownloader:
        downloader_model.seed_url = str(downloader_model.seed_url)
        config_downloader = {
            k:v for k,v in self._model_items(downloader_model) 
            if k != "name" and v 
        }

        try:
            downloader = self._downloaders[downloader_model.name](
                **config_downloader
            )
            return downloader

        except KeyError:
            log.error(
                f"RuleParseError: Downloader with name '{downloader_model.name}'"\
                " does not exist"
            )
            return
        except Exception as exception:
            log.error(
                f"RuleParseError: {exception}"
            )
            return
        
    def _create_parser(
        self,
        parser_model: ParserModel
    ) -> IParser:
        config_parser = {
            k:v for k,v in self._model_items(parser_model) 
            if k != "name" and v
        }

        try:
            parser = self._parsers[parser_model.name](
                **config_parser
            )
            return parser
        
        except KeyError:
            log.error(
                f"RuleParseError: Parser with name '{parser_model.name}'"\
                " does not exist"
            )
            return
        except Exception as exception:
            log.error(
                f"RuleParseError: {exception}"
            )
            return

    def _create_source(
        self,
        source_model: SourceModel
    ) -> Optional[Source]:
        downloader_model = source_model.downloader
        downloader = self._create_downloader(
            downloader_model=downloader_model
        )
        
        if not downloader: 
            return

        parser_model = source_model.parser
        parser = self._create_parser(
            parser_model=parser_model
        )
        
        if not parser:
            return
        
        source = Source(
            title=source_model.title,
            priority=source_model.priority,
            payload=source_model.payload,
            cooldown=source_model.cooldown,
            downloader=downloader,
            parser=parser
        )
        
        return source

    def _create_sources(
        self,
        sources_rules: dict
    ) -> list[Source]:
        if not sources_rules:
            return

        for source_rule in sources_rules.values():
            try:
                source_model = SourceModel.model_validate(source_rule)
                source = self._create_source(
                    source_model=source_model
                )

                if source: 
                    self._sources.append(source)

            except ValidationError as vErr:
                log.error(
                    f"Check source rule fields: {vErr}"
                )
            except Exception as exception:
                log.error(
                    f"Source rule was not parsed: {exception}"
                )

    def load(
        self
    ) -> None:
        self._sources.clear()
        for rule_file in self._rules_dir.glob(self._rules_pattern):
            with open(f"{rule_file}") as sources_file:
                sources_rule = self._yaml_load(sources_file)
                self._create_sources(sources_rule)