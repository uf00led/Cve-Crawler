import logging

from typing import Optional
from pathlib import Path

from yaml import (
    safe_load, 
    YAMLError
)

from pydantic import (
    ValidationError
)

from .source import (
    Source
)

from .rules_models import (
    ParserModel,
    DownloaderModel,
    SourceModel
)

from ..downloaders import (
    IDownloader,
    DownloaderRequests,
    DownloaderSelenium
)

from ..parsers import (
    IParser,
    ParserJson,
    ParserXml,
)

log = logging.getLogger(__name__)

class SourceLoader():
    """
    Initializes a SourceLoader instance responsible for managing and 
    loading data sources.

    :param rules_path: The path to the directory 
        containing rules for source loading. Defaults to "./sources_rules".
    """
    def __init__(
        self,
        rules_path: str = "./sources_rules"
    ) -> None:
        file_dir = f"{Path(__file__).parent}/"
        
        self._rules_pattern = "*.yaml"
        self._rules_dir = Path(file_dir + rules_path)
        self._sources = list()

        self._downloaders = {
            'Requests': DownloaderRequests,
            'Selenium': DownloaderSelenium
        }

        self._parsers = {
            'Json': ParserJson,
            'Xml' : ParserXml
        }

        self._model_items = lambda model: model.model_dump().items()

    @property
    def sources(
        self
    ) -> list:    
        """
        Retrieves the list of loaded sources.
        
        :return: A list of Source instances representing loaded data sources.
        """
        return self._sources
    
    @property
    def is_loaded(
        self
    ) -> bool:
        """
        Checks if any data sources are currently loaded.

        :return: True if sources have been loaded, False otherwise.
        """
        return True if len(self._sources) else False
    
    def _yaml_load(
        self,
        data: Optional[str]
    ):
        """
        Loads YAML formatted data.

        :param data: Optional YAML-formatted string data to be loaded.
        """

        try:
            yaml_dict = safe_load(data)
        except YAMLError as decodeError:
            log.error(
                f"YAMLError: Failed to decode the data into YAML. {decodeError}"
            )
            return
        return yaml_dict

    def _create_downloader(
        self,
        downloader_model: DownloaderModel,
    ) -> IDownloader:
        """
        Creates and configures a `Downloader` instance based on the 
        provided model.

        :param downloader_model: An instance of DownloaderModel containing 
            configuration details.
        :return: An instance of `IDownloader` implementing data retrieval 
            functionality.
        """
        
        downloader_model.seed_url = str(downloader_model.seed_url)
        config_downloader = {
            k:v for k,v in self._model_items(downloader_model) 
            if k != "name" and v 
        }

        try:
            downloader = self._downloaders[downloader_model.name](
                **config_downloader
            )
            return downloader

        except KeyError:
            log.error(
                f"RuleParseError: Downloader with name '{downloader_model.name}'"\
                " does not exist"
            )
            return
        except Exception as exception:
            log.error(
                f"RuleParseError: {exception}"
            )
            return
        
    def _create_parser(
        self,
        parser_model: ParserModel
    ) -> IParser:
        """
        Creates and configures a parser instance based on the provided model.

        :param parser_model: An instance of ParserModel containing 
            configuration details.
        :return: An instance of IParser implementing data parsing 
            functionality.
        """
        
        config_parser = {
            k:v for k,v in self._model_items(parser_model) 
            if k != "name" and v
        }

        try:
            parser = self._parsers[parser_model.name](
                **config_parser
            )
            return parser
        
        except KeyError:
            log.error(
                f"RuleParseError: Parser with name '{parser_model.name}'"\
                " does not exist"
            )
            return
        except Exception as exception:
            log.error(
                f"RuleParseError: {exception}"
            )
            return

    def _create_source(
        self,
        source_model: SourceModel
    ) -> Optional[Source]:
        """
        Creates a data source using the provided model specifications.

        :param source_model: An instance of SourceModel defining the 
            characteristics of the data source.
        :return: Optional Source instance representing a loaded data 
            source, if successfully created.
        """

        downloader_model = source_model.downloader
        downloader = self._create_downloader(
            downloader_model=downloader_model
        )
        
        if not downloader: 
            return

        parser_model = source_model.parser
        parser = self._create_parser(
            parser_model=parser_model
        )
        
        if not parser:
            return
        
        source = Source(
            title=source_model.title,
            priority=source_model.priority,
            payload=source_model.payload,
            cooldown=source_model.cooldown,
            downloader=downloader,
            parser=parser
        )
        
        return source

    def _create_sources(
        self,
        sources_rules: dict
    ) -> list[Source]:
        """
        Creates a list of data sources based on the provided rule definitions.

        :param sources_rules: A dictionary containing rules specifying the 
            properties of each data source.
        :return: A list of Source instances representing loaded data sources.
        """
        if not sources_rules:
            return

        for source_rule in sources_rules.values():
            try:
                source_model = SourceModel.model_validate(source_rule)
                source = self._create_source(
                    source_model=source_model
                )

                if source: 
                    self._sources.append(source)

            except ValidationError as vErr:
                log.error(
                    f"Check source rule fields: {vErr}"
                )
            except Exception as exception:
                log.error(
                    f"Source rule was not parsed: {exception}"
                )

    def load(
        self
    ) -> None:
        """
        Loads data sources based on the defined rules and configurations.
        """
        self._sources.clear()
        for rule_file in self._rules_dir.glob(self._rules_pattern):
            with open(f"{rule_file}") as sources_file:
                sources_rule = self._yaml_load(sources_file)
                self._create_sources(sources_rule)