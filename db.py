import logging
from collections.abc import Iterable

from sqlite3 import (
    connect,
    Connection,
    Error,
    Row
)

log = logging.getLogger(__name__)

def create_connection(
    db_file: str = "db.sqlite3"
) -> Connection | None: # Instead of Optional
    try:
        conn = connect(db_file)
        conn.row_factory = Row
        return conn
    
    except Error as SqliteErr:
        log.error(
            f"Can not connect to {db_file}. {SqliteErr}"
        )
    return None

def insert_data(
    conn: Connection, 
    table_name: str, 
    columns: list[str],
    values: tuple
) -> None:
    try:
        cur = conn.cursor()
        columns_str = ', '.join(columns)
        placeholders = ', '.join(['?' for _ in range(len(columns))])
        
        query = f"INSERT OR IGNORE INTO {table_name} ({columns_str}) VALUES ({placeholders})"
        cur.execute(query, values)
        conn.commit()
    
    except Error as SqliteErr:
        log.error(
            f"Can not insert to table {table_name}. {SqliteErr}"
        )

def update_data_by_id(
    conn: Connection, 
    table_name: str, 
    columns: list[str], 
    new_values: tuple, 
    row_id: int | str
) -> None:
    try:
        cur = conn.cursor()
        set_values = ', '.join([f"{col} = ?" for col in columns])
        values = (*new_values, row_id)
        
        query = f"UPDATE {table_name} SET {set_values} WHERE id = ?"
        cur.execute(query, values)
        conn.commit()

    except Error as SqliteErr:
        log.error(
            f"Can not update data in table {table_name} by {row_id}. {SqliteErr}"
        )

def find_id_by_params(
    conn: Connection, 
    table_name: str, 
    search_columns: list[str],  # -> to_dict
    search_values: tuple
) -> int | str | None:
    try:
        cur = conn.cursor()
        search_conditions = ' AND '.join([f"{col} = ?" for col in search_columns])
        
        query = f"SELECT id FROM {table_name} WHERE {search_conditions}"
        cur.execute(query, search_values)
        row = cur.fetchone()
        return row[0] if row else None
    
    except Error as SqliteErr:
        log.error(
            f"Can not find data in table {table_name}"\
            f"by values {search_values}. {SqliteErr}"
        )

def get_table_rows(
    conn: Connection, 
    table_name: str
) -> list[tuple] | None:
    try:
        cur = conn.cursor()
        cur.execute(f"SELECT * FROM {table_name}", ())
        rows = cur.fetchall()
        return rows
    
    except Error as SqliteErr:
        log.error(
            f"Can not get table {table_name}. {SqliteErr}"
        )

def execute_query(
    conn: Connection, 
    query: str, 
    values: tuple = (),
    is_return: bool = True,
    is_one: bool = False
) -> None:
    try:
        cur = conn.cursor()
        
        if is_return:
            executed = cur.execute(query, values)
            table_values = executed.fetchone() if is_one else executed.fetchall()
            return table_values
        else:
            cur.execute(query, values)
            conn.commit()
            return 
    except Error as SqliteErr:
        log.error(
            f"Can not execute query {query}. {SqliteErr}"
        )