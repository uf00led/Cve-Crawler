from .IParser import IParser

class ParserJson(IParser):
    """An inheritor of the `IParser`, which provides the 
    ability to parse given JSON to the requested fields.

    :param sep: separator in the fields paths
    :type sep: str
    """
    def __init__(
        self,
        sep: str = "."    
    ) -> None:
        """Constructor method."""
        self._sep = sep
        pass

    def parse(
        self,
        data: dict,
        fields: dict,
    ) -> dict:    
        """This function is the main function of this `Parser`. And, 
        as you can guess, it performs the parsing of JSON content.
        
        :param data: dictionary with the data to be searched for
        :type data: dict
        
        :param fields: dictionary of correspondence between names 
            of extracted parameters and paths to these parameters
        :type fields: dict
        
        :return: data dictionary from the given paths
        :rtype: dict if success, else NoneType

        data = {
            Nested: {
                One: {
                    ...
                }
                Another: [
                        Item_1,
                        Item_2,
                        ...
                        Item_n,
                    ]
                }
            }
        }

        fields = {
            name_1: Nested.One
            name_2: Nested.Another
            ...
            name_n: Nested
        }
        """
        result = {}
        for field, path in fields.items():
            result[field] = self._search(
                data=data,
                path=path
            )
        return result

    def _search(
        self,
        data: dict,
        path: str,
    ) -> str: # or dict/list
        """Function that returns an item from the dictionary along 
        the given path 
        
        :param data: search dictionary
        :type data: dict

        :param path: search path
        :type path: dict

        :return: element located in the given dictionary along 
            the given path
        :rtype: dict if success, else NoneType
        """
        tmp_data = data
        path_list = path.split(self._sep)
        
        try:
            for node in path_list:
                tmp_data = tmp_data[node]
        except:
            pass