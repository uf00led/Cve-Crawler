from .IParser import IParser

from json import loads, JSONDecodeError
from copy import deepcopy
import logging

log = logging.getLogger(__name__)

class ParserJson(IParser):
    """An inheritor of the `IParser`, which provides the 
    ability to parse given JSON to the requested fields.

    :param sep: separator in the fields paths
    :type sep: str
    """
    def __init__(
        self,
        sep: str = "."    
    ) -> None:
        """Constructor method."""
        self._sep = sep
        pass

    def parse(
        self,
        root: str,
        data: str,
        fields: dict,
    ) -> dict:    
        """This function is the main function of this `Parser`. And, 
        as you can guess, it performs the parsing of JSON content.
        
        :param data: string with the data to be searched for
        :type data: str
        
        :param fields: dictionary of correspondence between names 
            of extracted parameters and paths to these parameters
        :type fields: dict
        
        :return: data dictionary from the given paths
        :rtype: dict if success, else NoneType

        data = '''{
            "Nested": {
                "One": {
                    ...
                }
                "Another": [
                        Item_1,
                        Item_2,
                        ...
                        Item_n,
                    ]
                }
            }
        }'''

        fields = {
            "name_1": "Nested.One",
            "name_2": "Nested.Another"
            ...
            "name_n": "Nested"
        }
        """
        
        try:
            data_json = loads(data)

        except JSONDecodeError:
            log.error(
                f"JSONDecodeError: Failed to decode the data into JSON."
            )
            return
        
        root_json = self._search(
            data=data_json,
            path=root,
        )

        extracted = {}
        parsed_data = []

        for entry in root_json():
            for field, path in fields.items():
                extracted[field] = self._search(
                    data=entry,
                    path=path
                )
                log.debug(f"Extracted data to '{field}' is {extracted[field]}")
            
            parsed_data.append(deepcopy(extracted))
            extracted.clear()
        return parsed_data

    def _search(    
        self,
        data: dict,
        path: str,
    ) -> str: # or dict/list or None
        """Function that returns an item from the dictionary along 
        the given path 
        
        :param data: search dictionary
        :type data: dict

        :param path: search path
        :type path: dict

        :return: element located in the given dictionary along 
            the given path
        :rtype: dict if success, else NoneType
        """
        
        path_trail = [node.strip() for node in path.split(self._sep)]
        search_data = deepcopy(data)
        
        try:
            for node in path_trail:
                search_data = search_data[node]
            return search_data
        
        except KeyError as KE:
            log.info(f"KeyError: Dictionary hasn\'t element by path {path}.")
            return